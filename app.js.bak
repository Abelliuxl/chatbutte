const STORAGE_KEY = 'chatbutte_state_v1';

if (window.marked) {
  marked.setOptions({
    gfm: true,
    breaks: true,
    highlight(code, language) {
      if (window.hljs) {
        const hasLang = language && hljs.getLanguage(language);
        return hasLang
          ? hljs.highlight(code, { language }).value
          : hljs.highlightAuto(code).value;
      }
      return code;
    },
  });
}

const defaultState = {
  profiles: [],
  activeProfileId: null,
  topics: [],
  activeTopicId: null,
  settings: {
    sendKey: 'enter',
    // è‡ªå®šä¹‰æ€ç»´é“¾æ ‡ç­¾æ ¼å¼ï¼ˆç”¨æˆ·å¯æ‰©å±•ï¼‰
    customReasoningTags: [
      { start: '</think>

const elements = {
  topicList: document.getElementById('topicList'),
  topicTitle: document.getElementById('topicTitle'),
  topicPromptPreview: document.getElementById('topicPromptPreview'),
  messages: document.getElementById('messages'),
  messageInput: document.getElementById('messageInput'),
  sendBtn: document.getElementById('sendBtn'),
  sendHint: document.getElementById('sendHint'),
  profileSelect: document.getElementById('profileSelect'),
  clearChatBtn: document.getElementById('clearChatBtn'),
  newChatBtn: document.getElementById('newChatBtn'),
  addTopicBtn: document.getElementById('addTopicBtn'),
  settingsBtn: document.getElementById('settingsBtn'),
  settingsModal: document.getElementById('settingsModal'),
  closeSettingsBtn: document.getElementById('closeSettingsBtn'),
  profileList: document.getElementById('profileList'),
  profileForm: document.getElementById('profileForm'),
  profileId: document.getElementById('profileId'),
  profileUrl: document.getElementById('profileUrl'),
  profileKey: document.getElementById('profileKey'),
  profileModel: document.getElementById('profileModel'),
  profileCancelBtn: document.getElementById('profileCancelBtn'),
  sendKeySelect: document.getElementById('sendKeySelect'),
  topicModal: document.getElementById('topicModal'),
  topicModalTitle: document.getElementById('topicModalTitle'),
  closeTopicBtn: document.getElementById('closeTopicBtn'),
  topicForm: document.getElementById('topicForm'),
  topicId: document.getElementById('topicId'),
  topicName: document.getElementById('topicName'),
  topicPrompt: document.getElementById('topicPrompt'),
  topicHistoryCount: document.getElementById('topicHistoryCount'),
  topicTemperature: document.getElementById('topicTemperature'),
  topicTemperatureValue: document.getElementById('topicTemperatureValue'),
  topicCancelBtn: document.getElementById('topicCancelBtn'),
  menuToggle: document.getElementById('menuToggle'),
  sidebarClose: document.getElementById('sidebarClose'),
  sidebarOverlay: document.getElementById('sidebarOverlay'),
  sidebar: document.querySelector('.sidebar'),
  exportBtn: document.getElementById('exportBtn'),
  importBtn: document.getElementById('importBtn'),
  importFileInput: document.getElementById('importFileInput'),
  resetBtn: document.getElementById('resetBtn'),
  // Gist åŒæ­¥ç›¸å…³å…ƒç´ 
  gistToken: document.getElementById('gistToken'),
  gistId: document.getElementById('gistId'),
  uploadBtn: document.getElementById('uploadBtn'),
  downloadBtn: document.getElementById('downloadBtn'),
  saveGistBtn: document.getElementById('saveGistBtn'),
  syncStatus: document.getElementById('syncStatus'),
};

let state = loadState();

function loadState() {
  const raw = localStorage.getItem(STORAGE_KEY);
  if (!raw) {
    return structuredClone(defaultState);
  }
  try {
    const parsed = JSON.parse(raw);

    // æ¸…ç† profiles ä¸­çš„æ—§ name å­—æ®µ
    if (parsed.profiles && Array.isArray(parsed.profiles)) {
      parsed.profiles = parsed.profiles.map((profile) => {
        const { name, ...rest } = profile;
        return rest;
      });
    }

    return {
      ...structuredClone(defaultState),
      ...parsed,
      settings: { ...structuredClone(defaultState.settings), ...(parsed.settings || {}) },
      messagesByTopic: parsed.messagesByTopic || {},
    };
  } catch (error) {
    return structuredClone(defaultState);
  }
}

function saveState() {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
}

function ensureActiveSelections() {
  if (!state.activeTopicId && state.topics.length) {
    state.activeTopicId = state.topics[0].id;
  }
  if (!state.activeProfileId && state.profiles.length) {
    state.activeProfileId = state.profiles[0].id;
  }
}

function openModal(modal) {
  modal.classList.add('open');
  modal.setAttribute('aria-hidden', 'false');
  // æ‰“å¼€ modal æ—¶è‡ªåŠ¨å…³é—­ sidebar
  elements.sidebar.classList.remove('open');
  elements.sidebarOverlay.classList.remove('open');
}

function closeModal(modal) {
  modal.classList.remove('open');
  modal.setAttribute('aria-hidden', 'true');
}

function createId(prefix) {
  return `${prefix}_${Math.random().toString(36).slice(2, 9)}`;
}

function renderTopics() {
  elements.topicList.innerHTML = '';
  state.topics.forEach((topic, index) => {
    const card = document.createElement('div');
    card.className = 'topic-card';
    card.dataset.topicId = topic.id;
    card.dataset.index = index;
    card.draggable = true;
    if (topic.id === state.activeTopicId) {
      card.classList.add('active');
    }

    const title = document.createElement('h4');
    title.className = 'topic-title';
    title.textContent = topic.name;

    const actions = document.createElement('div');
    actions.className = 'topic-actions';
    const editBtn = document.createElement('button');
    editBtn.className = 'ghost-btn';
    editBtn.textContent = 'ç¼–è¾‘';
    editBtn.addEventListener('click', (event) => {
      event.stopPropagation();
      openTopicModal(topic);
    });

    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'ghost-btn';
    deleteBtn.textContent = 'åˆ é™¤';
    deleteBtn.addEventListener('click', (event) => {
      event.stopPropagation();
      removeTopic(topic.id);
    });

    actions.append(editBtn, deleteBtn);
    card.append(title, actions);

    // æ‹–æ‹½å¼€å§‹
    card.addEventListener('dragstart', (event) => {
      card.classList.add('dragging');
      event.dataTransfer.effectAllowed = 'move';
      event.dataTransfer.setData('text/plain', String(index));
    });

    // æ‹–æ‹½ç»“æŸ
    card.addEventListener('dragend', () => {
      card.classList.remove('dragging');
      document.querySelectorAll('.topic-card').forEach(c => {
        c.classList.remove('drag-over');
      });
    });

    // æ‹–æ‹½ç»è¿‡
    card.addEventListener('dragover', (event) => {
      event.preventDefault();
      event.dataTransfer.dropEffect = 'move';
      if (card !== document.querySelector('.dragging')) {
        card.classList.add('drag-over');
      }
    });

    // æ‹–æ‹½ç¦»å¼€
    card.addEventListener('dragleave', () => {
      card.classList.remove('drag-over');
    });

    // æ”¾ä¸‹
    card.addEventListener('drop', (event) => {
      event.preventDefault();
      const fromIndex = parseInt(event.dataTransfer.getData('text/plain'));
      const toIndex = index;

      if (fromIndex !== toIndex) {
        // é‡æ–°æ’åºæ•°ç»„
        const [movedTopic] = state.topics.splice(fromIndex, 1);
        state.topics.splice(toIndex, 0, movedTopic);
        saveState();
        render();
      }
    });

    card.addEventListener('click', () => {
      state.activeTopicId = topic.id;
      // åˆ‡æ¢è¯é¢˜æ—¶ï¼ŒåŒæ­¥è¯¥è¯é¢˜çš„æ¨¡å‹åˆ°å…¨å±€
      if (topic.activeProfileId) {
        state.activeProfileId = topic.activeProfileId;
      }
      saveState();
      render();
    });
    elements.topicList.appendChild(card);
  });
}

function renderTopicHeader() {
  const activeTopic = state.topics.find((topic) => topic.id === state.activeTopicId);
  if (!activeTopic) {
    elements.topicTitle.textContent = 'æœªé€‰æ‹©å­è¯é¢˜';
    elements.topicPromptPreview.textContent = 'è¯·é€‰æ‹©æˆ–åˆ›å»ºä¸€ä¸ªå­è¯é¢˜ï¼Œå¹¶å¡«å†™ç³»ç»Ÿæç¤ºè¯ã€‚';
    return;
  }
  elements.topicTitle.textContent = activeTopic.name;
  elements.topicPromptPreview.textContent = activeTopic.prompt || 'æœªè®¾ç½®ç³»ç»Ÿæç¤ºè¯';
}

function renderMessages() {
  elements.messages.innerHTML = '';
  const activeTopic = state.activeTopicId;
  if (!activeTopic) return;
  const messages = state.messagesByTopic[activeTopic] || [];
  messages.forEach((message) => {
    elements.messages.appendChild(createMessageBubble(message));
  });
  elements.messages.scrollTop = elements.messages.scrollHeight;
}

function createMessageBubble(message) {
  const bubble = document.createElement('div');
  bubble.className = `message ${message.role}`;
  if (message.id) {
    bubble.dataset.messageId = message.id;
  }
  if (message.role === 'error') {
    bubble.classList.add('error');
  }

  // å¦‚æœæœ‰æ€ç»´é“¾å†…å®¹ï¼Œæ·»åŠ æ€ç»´é“¾å°æ°”æ³¡
  if (message.reasoning) {
    const reasoningBubble = document.createElement('div');
    reasoningBubble.className = 'message-reasoning';
    updateReasoningBubble(reasoningBubble, message.reasoning, false);
    bubble.appendChild(reasoningBubble);
  }

  // æ¶ˆæ¯å†…å®¹å®¹å™¨
  const contentWrapper = document.createElement('div');
  contentWrapper.className = 'message-content';
  contentWrapper.innerHTML = renderMarkdown(message.content || '').trim();
  bubble.appendChild(contentWrapper);

  // æ·»åŠ å¤åˆ¶æŒ‰é’®ï¼ˆerror æ¶ˆæ¯ä¹Ÿæ˜¾ç¤ºï¼‰
  const copyBtn = document.createElement('button');
  copyBtn.className = 'message-copy-btn';
  copyBtn.innerHTML = `
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
      <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
    </svg>
    <span>å¤åˆ¶</span>
  `;
  copyBtn.title = 'å¤åˆ¶æ¶ˆæ¯';

  // å¤åˆ¶æŒ‰é’®ç‚¹å‡»äº‹ä»¶
  copyBtn.addEventListener('click', async () => {
    const text = message.content || '';
    try {
      await navigator.clipboard.writeText(text);
      // æ˜¾ç¤ºå¤åˆ¶æˆåŠŸçŠ¶æ€
      copyBtn.classList.add('copied');
      copyBtn.innerHTML = `
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polyline points="20 6 9 17 4 12"></polyline>
        </svg>
        <span>å·²å¤åˆ¶</span>
      `;
      // 2ç§’åæ¢å¤åŸçŠ¶
      setTimeout(() => {
        copyBtn.classList.remove('copied');
        copyBtn.innerHTML = `
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
          </svg>
          <span>å¤åˆ¶</span>
        `;
      }, 2000);
    } catch (err) {
      console.error('å¤åˆ¶å¤±è´¥:', err);
    }
  });

  bubble.appendChild(copyBtn);
  return bubble;
}

function renderMarkdown(content) {
  if (window.marked) {
    return marked.parse(content);
  }
  return content.replaceAll('<', '&lt;').replaceAll('>', '&gt;').replaceAll('\n', '<br>');
}

function renderProfiles() {
  elements.profileSelect.innerHTML = '';
  if (!state.profiles.length) {
    const option = document.createElement('option');
    option.value = '';
    option.textContent = 'æœªé…ç½®æ¨¡å‹';
    elements.profileSelect.appendChild(option);
  }

  state.profiles.forEach((profile) => {
    const option = document.createElement('option');
    option.value = profile.id;
    option.textContent = profile.model;
    if (profile.id === state.activeProfileId) option.selected = true;
    elements.profileSelect.appendChild(option);
  });

  elements.profileList.innerHTML = '';
  state.profiles.forEach((profile) => {
    const card = document.createElement('div');
    card.className = 'card profile-item';

    const info = document.createElement('div');
    const name = document.createElement('div');
    name.textContent = profile.model;
    const meta = document.createElement('div');
    meta.className = 'profile-meta';
    meta.textContent = profile.apiUrl;
    info.append(name, meta);

    const actions = document.createElement('div');
    const editBtn = document.createElement('button');
    editBtn.className = 'ghost-btn';
    editBtn.textContent = 'ç¼–è¾‘';
    editBtn.addEventListener('click', () => fillProfileForm(profile));

    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'ghost-btn';
    deleteBtn.textContent = 'åˆ é™¤';
    deleteBtn.addEventListener('click', () => removeProfile(profile.id));

    actions.append(editBtn, deleteBtn);
    card.append(info, actions);
    elements.profileList.appendChild(card);
  });
}

function renderSettings() {
  elements.sendKeySelect.value = state.settings.sendKey;
  updateSendHint();
  renderGistConfig();
}

function updateSendHint() {
  // æ£€æµ‹æ“ä½œç³»ç»Ÿå¹³å°
  const isMac = /Mac|iPod|iPhone|iPad/.test(navigator.platform);

  const map = {
    enter: isMac
      ? 'Enter å‘é€ Â· Cmd/Ctrl/Option + Enter æ¢è¡Œ'
      : 'Enter å‘é€ Â· Ctrl/Alt + Enter æ¢è¡Œ',
    cmd: 'Cmd + Enter å‘é€ Â· å…¶ä»–ç»„åˆé”®æ¢è¡Œ',
    ctrl: 'Ctrl + Enter å‘é€ Â· å…¶ä»–ç»„åˆé”®æ¢è¡Œ',
    alt: isMac
      ? 'Option + Enter å‘é€ Â· å…¶ä»–ç»„åˆé”®æ¢è¡Œ'
      : 'Alt + Enter å‘é€ Â· å…¶ä»–ç»„åˆé”®æ¢è¡Œ',
  };
  elements.sendHint.textContent = map[state.settings.sendKey] || '';
}

function render() {
  ensureActiveSelections();
  renderTopics();
  renderTopicHeader();
  renderMessages();
  renderProfiles();
  renderSettings();
  saveState();
}

function getActiveProfile() {
  return state.profiles.find((profile) => profile.id === state.activeProfileId);
}

function getActiveTopic() {
  return state.topics.find((topic) => topic.id === state.activeTopicId);
}

function pushMessage(topicId, role, content, id = null) {
  if (!state.messagesByTopic[topicId]) {
    state.messagesByTopic[topicId] = [];
  }
  const message = { id: id || createId('msg'), role, content, time: Date.now() };
  state.messagesByTopic[topicId].push(message);
  saveState();
  return message;
}

// æ€ç»´é“¾åŠ¨ç”»çŠ¶æ€
const reasoningAnimations = new Map();

// æ”¯æŒçš„æ€ç»´é“¾æ ‡ç­¾æ ¼å¼
const REASONING_TAGS = [
  { start: '<think>', end: '</think>' },
  { start: '<thought>', end: '</thought>' },
  { start: '<reasoning>', end: '</reasoning>' },
  { start: '<think_process>', end: '</think_process>' },
];

// ä»æ–‡æœ¬ä¸­æå–æ€ç»´é“¾å†…å®¹
function extractReasoning(content) {
  const reasoningParts = [];
  let cleanedContent = content;

  for (const tag of REASONING_TAGS) {
    const regex = new RegExp(`${tag.start}([\\s\\S]*?)${tag.end}`, 'gi');
    const matches = content.match(regex);

    if (matches) {
      matches.forEach((match) => {
        const extracted = match
          .replace(new RegExp(`^${tag.start}`, 'i'), '')
          .replace(new RegExp(`${tag.end}$`, 'i'), '')
          .trim();
        if (extracted) {
          reasoningParts.push(extracted);
        }
      });
    }

    // ç§»é™¤æ€ç»´é“¾æ ‡ç­¾
    cleanedContent = cleanedContent.replace(regex, '').trim();
  }

  return {
    reasoning: reasoningParts.join('\n\n---\n\n'),
    cleanedContent: cleanedContent,
    hasReasoning: reasoningParts.length > 0,
  };
}

function updateReasoningBubble(bubble, reasoning, isLoading = false) {
  if (isLoading) {
    // æ˜¾ç¤ºåŠ è½½åŠ¨ç”»
    let animationInterval = reasoningAnimations.get(bubble);
    if (!animationInterval) {
      let dots = 0;
      bubble.innerHTML = `<span class="reasoning-text">æ€è€ƒä¸­</span><span class="reasoning-dots">${'.'.repeat(dots)}</span>`;
      bubble.classList.add('loading');
      animationInterval = setInterval(() => {
        dots = (dots + 1) % 4;
        const dotsElement = bubble.querySelector('.reasoning-dots');
        if (dotsElement) {
          dotsElement.textContent = '.'.repeat(dots || 1);
        }
      }, 300);
      reasoningAnimations.set(bubble, animationInterval);
    }
  } else {
    // åœæ­¢åŠ¨ç”»ï¼Œæ˜¾ç¤ºé¢„è§ˆæ–‡æœ¬
    let animationInterval = reasoningAnimations.get(bubble);
    if (animationInterval) {
      clearInterval(animationInterval);
      reasoningAnimations.delete(bubble);
    }
    bubble.classList.remove('loading');

    // è·å–é¢„è§ˆæ–‡æœ¬ï¼ˆæœ€å¤šä¸€è¡Œï¼‰
    const previewText = reasoning.slice(0, 50) + (reasoning.length > 50 ? '...' : '');
    bubble.innerHTML = `
      <span class="reasoning-text">${previewText}</span>
      <span class="reasoning-expand">ğŸ“–</span>
    `;
    bubble.title = reasoning; // hover æ—¶æ˜¾ç¤ºå®Œæ•´å†…å®¹
  }
}

function updateMessageContent(topicId, messageId, content, reasoning = null) {
  const list = state.messagesByTopic[topicId] || [];
  const target = list.find((message) => message.id === messageId);
  if (!target) return;
  target.content = content;
  if (reasoning !== null) {
    target.reasoning = reasoning;
  }
  saveState();
  const bubble = elements.messages.querySelector(`[data-message-id=\"${messageId}\"]`);
  if (bubble) {
    // æ›´æ–°æ€ç»´é“¾å†…å®¹
    if (reasoning !== null) {
      let reasoningBubble = bubble.querySelector('.message-reasoning');
      if (!reasoningBubble && reasoning) {
        // å¦‚æœæ²¡æœ‰æ€ç»´é“¾æ°”æ³¡ä½†æœ‰å†…å®¹ï¼Œåˆ›å»ºä¸€ä¸ª
        reasoningBubble = document.createElement('div');
        reasoningBubble.className = 'message-reasoning';
        const contentWrapper = bubble.querySelector('.message-content');
        bubble.insertBefore(reasoningBubble, contentWrapper);
      }
      if (reasoningBubble) {
        // å¦‚æœæ¶ˆæ¯å†…å®¹ä¸ºç©ºï¼Œæ˜¾ç¤ºåŠ è½½åŠ¨ç”»
        const isLoading = !content || content.trim().length === 0;
        updateReasoningBubble(reasoningBubble, reasoning, isLoading);
      }
    }

    const contentWrapper = bubble.querySelector('.message-content');
    if (contentWrapper) {
      contentWrapper.innerHTML = renderMarkdown(content);
    } else {
      // å¦‚æœæ—§æ¶ˆæ¯æ²¡æœ‰ message-content åŒ…è£…å™¨ï¼ˆå‘åå…¼å®¹ï¼‰ï¼Œé‡æ–°åˆ›å»ºæ•´ä¸ªæ°”æ³¡
      bubble.innerHTML = '';
      const newContentWrapper = document.createElement('div');
      newContentWrapper.className = 'message-content';
      newContentWrapper.innerHTML = renderMarkdown(content);
      bubble.appendChild(newContentWrapper);

      // æ·»åŠ å¤åˆ¶æŒ‰é’®
      const copyBtn = document.createElement('button');
      copyBtn.className = 'message-copy-btn';
      copyBtn.innerHTML = `
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
          <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
        </svg>
        <span>å¤åˆ¶</span>
      `;
      copyBtn.title = 'å¤åˆ¶æ¶ˆæ¯';

      copyBtn.addEventListener('click', async () => {
        const text = content || '';
        try {
          await navigator.clipboard.writeText(text);
          copyBtn.classList.add('copied');
          copyBtn.innerHTML = `
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <polyline points="20 6 9 17 4 12"></polyline>
            </svg>
            <span>å·²å¤åˆ¶</span>
          `;
          setTimeout(() => {
            copyBtn.classList.remove('copied');
            copyBtn.innerHTML = `
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
              </svg>
              <span>å¤åˆ¶</span>
            `;
          }, 2000);
        } catch (err) {
          console.error('å¤åˆ¶å¤±è´¥:', err);
        }
      });

      bubble.appendChild(copyBtn);
    }
    elements.messages.scrollTop = elements.messages.scrollHeight;
  }
}

async function generateTopicName(text, profile) {
  const payload = {
    model: profile.model,
    messages: [
      {
        role: 'system',
        content: 'è¯·ç”¨ä¸€å¥è¯æ€»ç»“ä»¥ä¸‹å†…å®¹ä½œä¸ºèŠå¤©è¯é¢˜åç§°ï¼Œè¦æ±‚ç®€æ´æ˜äº†ï¼Œä¸è¶…è¿‡20ä¸ªå­—ã€‚åªè¿”å›è¯é¢˜åç§°ï¼Œä¸è¦æ·»åŠ ä»»ä½•å…¶ä»–è§£é‡Šã€‚'
      },
      {
        role: 'user',
        content: text
      }
    ],
    temperature: 0.3
  };

  const headers = {
    'Content-Type': 'application/json',
  };
  if (profile.apiKey) {
    headers.Authorization = `Bearer ${profile.apiKey}`;
  }

  const response = await fetch(profile.apiUrl, {
    method: 'POST',
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    throw new Error(`è¯·æ±‚å¤±è´¥: ${response.status}`);
  }

  const data = await response.json();
  return data?.choices?.[0]?.message?.content || 'æ–°è¯é¢˜';
}

async function sendMessage() {
  const text = elements.messageInput.value.trim();
  let activeTopic = getActiveTopic();
  if (!text) return;
  const profile = getActiveProfile();
  if (!profile) {
    alert('è¯·å…ˆåœ¨è®¾ç½®é‡Œé…ç½®æ¨¡å‹ã€‚');
    return;
  }

  // å¦‚æœæ²¡æœ‰æ¿€æ´»è¯é¢˜ï¼Œè‡ªåŠ¨åˆ›å»ºä¸€ä¸ª
  if (!activeTopic) {
    try {
      const topicName = await generateTopicName(text, profile);
      const topicId = createId('topic');
      state.topics.push({
        id: topicId,
        name: topicName,
        prompt: '',
        historyCount: 12,
        temperature: 0.7,
        activeProfileId: state.activeProfileId
      });
      state.activeTopicId = topicId;
      saveState();
      render();
      activeTopic = getActiveTopic();
    } catch (error) {
      // å¦‚æœç”Ÿæˆè¯é¢˜åç§°å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤åç§°
      const topicId = createId('topic');
      state.topics.push({
        id: topicId,
        name: 'æ–°è¯é¢˜',
        prompt: '',
        historyCount: 12,
        temperature: 0.7,
        activeProfileId: state.activeProfileId
      });
      state.activeTopicId = topicId;
      saveState();
      render();
      activeTopic = getActiveTopic();
    }
  }

  elements.messageInput.value = '';
  pushMessage(activeTopic.id, 'user', text);
  renderMessages();

  const historyMessages = (state.messagesByTopic[activeTopic.id] || [])
    .filter((message) => message.role === 'user' || message.role === 'assistant');

  const recentMessages = historyMessages.slice(-(activeTopic.historyCount || 12)).map((message) => ({
    role: message.role,
    content: message.content,
  }));

  const assistantMessage = pushMessage(activeTopic.id, 'assistant', '');
  renderMessages();

  const payload = {
    model: profile.model,
    messages: [
      ...(activeTopic.prompt ? [{ role: 'system', content: activeTopic.prompt }] : []),
      ...recentMessages,
    ],
    temperature: Number(activeTopic.temperature || 0.7),
    stream: true,
  };

  try {
    const result = await streamChatCompletion(profile, payload, (_delta, full, reasoning) => {
      updateMessageContent(activeTopic.id, assistantMessage.id, full, reasoning);
    });
    if (!result || !result.content) {
      updateMessageContent(activeTopic.id, assistantMessage.id, 'æœªæ”¶åˆ°æœ‰æ•ˆè¿”å›ã€‚');
    }
  } catch (error) {
    updateMessageContent(activeTopic.id, assistantMessage.id, `å‡ºé”™äº†ï¼š${error.message}`);
    const target = state.messagesByTopic[activeTopic.id].find(
      (message) => message.id === assistantMessage.id
    );
    if (target) {
      target.role = 'error';
    }
    renderMessages();
  }
}

async function streamChatCompletion(profile, payload, onDelta) {
  const headers = {
    'Content-Type': 'application/json',
  };
  if (profile.apiKey) {
    headers.Authorization = `Bearer ${profile.apiKey}`;
  }

  const response = await fetch(profile.apiUrl, {
    method: 'POST',
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    throw new Error(`è¯·æ±‚å¤±è´¥: ${response.status}`);
  }

  const contentType = response.headers.get('content-type') || '';
  if (!response.body || !payload.stream || contentType.includes('application/json')) {
    const data = await response.json();
    const message = data?.choices?.[0]?.message?.content;
    const reasoning = data?.choices?.[0]?.message?.reasoning_content || '';

    if (!message) {
      throw new Error('è¿”å›å†…å®¹ä¸ºç©ºï¼Œè¯·ç¡®è®¤ API æ ¼å¼æ˜¯å¦å…¼å®¹ OpenAIã€‚');
    }

    // æ£€æŸ¥æ¶ˆæ¯ä¸­æ˜¯å¦æœ‰æ€ç»´é“¾æ ‡ç­¾
    const extracted = extractReasoning(message);
    const finalReasoning = reasoning || extracted.reasoning;
    const finalMessage = extracted.cleanedContent;

    if (finalReasoning) {
      onDelta('', finalMessage, finalReasoning);
    }

    return { content: finalMessage, reasoning: finalReasoning };
  }

  const reader = response.body.getReader();
  const decoder = new TextDecoder('utf-8');
  let buffer = '';
  let full = '';
  let fullReasoning = '';

  while (true) {
    const { value, done } = await reader.read();
    if (done) break;
    buffer += decoder.decode(value, { stream: true });
    const lines = buffer.split('\n');
    buffer = lines.pop() || '';
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed.startsWith('data:')) continue;
      const data = trimmed.replace(/^data:\s*/, '');
      if (data === '[DONE]') {
        // æœ€ç»ˆå¤„ç†ï¼šæ£€æŸ¥å†…å®¹ä¸­æ˜¯å¦æœ‰æ€ç»´é“¾æ ‡ç­¾
        const extracted = extractReasoning(full);
        return {
          content: extracted.cleanedContent,
          reasoning: extracted.reasoning || fullReasoning,
        };
      }
      try {
        const json = JSON.parse(data);
        const delta = json?.choices?.[0]?.delta?.content || '';
        const reasoningDelta = json?.choices?.[0]?.delta?.reasoning_content || '';
        const message = json?.choices?.[0]?.message?.content || '';
        const reasoning = json?.choices?.[0]?.message?.reasoning_content || '';
        const chunk = delta || message;

        // å¤„ç† reasoning_content å­—æ®µ
        if (reasoningDelta || reasoning) {
          fullReasoning += reasoningDelta || reasoning;
          onDelta('', full, fullReasoning);
        }

        // å¤„ç†å†…å®¹å¢é‡
        if (chunk) {
          full += chunk;

          // æ£€æŸ¥æ˜¯å¦æœ‰æ€ç»´é“¾æ ‡ç­¾ï¼Œå®æ—¶æå–
          const extracted = extractReasoning(full);
          if (extracted.hasReasoning) {
            // æœ‰æ€ç»´é“¾æ ‡ç­¾ï¼Œä½¿ç”¨æ¸…ç†åçš„å†…å®¹
            onDelta('', extracted.cleanedContent, extracted.reasoning || fullReasoning);
          } else {
            // æ²¡æœ‰æ€ç»´é“¾æ ‡ç­¾ï¼Œä½¿ç”¨åŸå§‹å†…å®¹
            onDelta(chunk, full, fullReasoning);
          }
        }
      } catch (error) {
        // ignore parse errors from partial lines
      }
    }
  }

  // æœ€ç»ˆå¤„ç†ï¼šæ£€æŸ¥å†…å®¹ä¸­æ˜¯å¦æœ‰æ€ç»´é“¾æ ‡ç­¾
  const extracted = extractReasoning(full);
  return {
    content: extracted.cleanedContent,
    reasoning: extracted.reasoning || fullReasoning,
  };
}

function openTopicModal(topic) {
  if (topic) {
    elements.topicModalTitle.textContent = 'ç¼–è¾‘å­è¯é¢˜';
    elements.topicId.value = topic.id;
    elements.topicName.value = topic.name;
    elements.topicPrompt.value = topic.prompt || '';
    elements.topicHistoryCount.value = topic.historyCount || 12;
    elements.topicTemperature.value = topic.temperature || 0.7;
    elements.topicTemperatureValue.textContent = Number(topic.temperature || 0.7).toFixed(2);
  } else {
    elements.topicModalTitle.textContent = 'æ–°å¢å­è¯é¢˜';
    elements.topicId.value = '';
    elements.topicName.value = '';
    elements.topicPrompt.value = '';
    elements.topicHistoryCount.value = 12;
    elements.topicTemperature.value = 0.7;
    elements.topicTemperatureValue.textContent = '0.70';
  }
  openModal(elements.topicModal);
}

function removeTopic(id) {
  if (!confirm('ç¡®å®šåˆ é™¤è¯¥å­è¯é¢˜å—ï¼Ÿæ­¤æ“ä½œä¸ä¼šåˆ é™¤å·²ä¿å­˜çš„æ¶ˆæ¯ï¼Œä½†ä¼šéšè—å®ƒä»¬ã€‚')) {
    return;
  }
  state.topics = state.topics.filter((topic) => topic.id !== id);
  if (state.activeTopicId === id) {
    state.activeTopicId = state.topics.length ? state.topics[0].id : null;
  }
  saveState();
  render();
}

function fillProfileForm(profile) {
  elements.profileId.value = profile.id;
  elements.profileUrl.value = profile.apiUrl;
  elements.profileKey.value = profile.apiKey || '';
  elements.profileModel.value = profile.model;
  openModal(elements.settingsModal);
}

function removeProfile(id) {
  if (!confirm('ç¡®å®šåˆ é™¤è¯¥æ¨¡å‹é…ç½®å—ï¼Ÿ')) return;
  state.profiles = state.profiles.filter((profile) => profile.id !== id);
  if (state.activeProfileId === id) {
    state.activeProfileId = state.profiles.length ? state.profiles[0].id : null;
  }
  saveState();
  render();
}

function resetProfileForm() {
  elements.profileId.value = '';
  elements.profileUrl.value = '';
  elements.profileKey.value = '';
  elements.profileModel.value = '';
}

function handleTopicSubmit(event) {
  event.preventDefault();
  const id = elements.topicId.value || createId('topic');
  const existing = state.topics.find((topic) => topic.id === id);
  if (existing) {
    existing.name = elements.topicName.value.trim();
    existing.prompt = elements.topicPrompt.value.trim();
    existing.historyCount = parseInt(elements.topicHistoryCount.value) || 12;
    existing.temperature = parseFloat(elements.topicTemperature.value) || 0.7;
  } else {
    state.topics.push({
      id,
      name: elements.topicName.value.trim(),
      prompt: elements.topicPrompt.value.trim(),
      historyCount: parseInt(elements.topicHistoryCount.value) || 12,
      temperature: parseFloat(elements.topicTemperature.value) || 0.7,
      activeProfileId: state.activeProfileId
    });
  }
  state.activeTopicId = id;
  saveState();
  closeModal(elements.topicModal);
  render();
}

function handleProfileSubmit(event) {
  event.preventDefault();
  const id = elements.profileId.value || createId('profile');
  const data = {
    id,
    apiUrl: elements.profileUrl.value.trim(),
    apiKey: elements.profileKey.value.trim(),
    model: elements.profileModel.value.trim(),
  };
  const existing = state.profiles.find((profile) => profile.id === id);
  if (existing) {
    Object.assign(existing, data);
  } else {
    state.profiles.push(data);
  }
  state.activeProfileId = id;
  resetProfileForm();
  saveState();
  render();
}

function handleKeydown(event) {
  if (event.key !== 'Enter') return;
  // ä¸­æ–‡å­—ç¬¦è¾“å…¥è¿‡ç¨‹ä¸­ä¸å¤„ç†
  if (event.isComposing) return;

  const sendKey = state.settings.sendKey;
  const isCtrl = event.ctrlKey;
  const isMeta = event.metaKey; // Mac Cmd
  const isAlt = event.altKey; // Mac Option / Windows Alt
  const hasModifier = isCtrl || isMeta || isAlt;

  const shouldSend =
    (sendKey === 'enter' && !hasModifier) ||
    (sendKey === 'ctrl' && isCtrl && !isMeta && !isAlt) ||
    (sendKey === 'cmd' && isMeta && !isCtrl && !isAlt) ||
    (sendKey === 'alt' && isAlt && !isCtrl && !isMeta);

  if (shouldSend) {
    event.preventDefault();
    sendMessage();
  } else {
    // å…¶ä»–æƒ…å†µéƒ½æ’å…¥æ¢è¡Œç¬¦
    event.preventDefault();
    const textarea = event.target;
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const value = textarea.value;
    textarea.value = value.slice(0, start) + '\n' + value.slice(end);
    textarea.selectionStart = textarea.selectionEnd = start + 1;
  }
}

function initListeners() {
  elements.sendBtn.addEventListener('click', sendMessage);
  elements.messageInput.addEventListener('keydown', handleKeydown);

  elements.profileSelect.addEventListener('change', (event) => {
    const newProfileId = event.target.value || null;
    state.activeProfileId = newProfileId;

    // å¦‚æœæœ‰å½“å‰è¯é¢˜ï¼ŒåŒæ­¥æ›´æ–°è¯¥è¯é¢˜çš„æ¨¡å‹
    if (state.activeTopicId) {
      const activeTopic = state.topics.find((topic) => topic.id === state.activeTopicId);
      if (activeTopic) {
        activeTopic.activeProfileId = newProfileId;
      }
    }

    saveState();
    renderProfiles();
  });

  elements.clearChatBtn.addEventListener('click', () => {
    const activeTopic = getActiveTopic();
    if (!activeTopic) return;
    if (!confirm('ç¡®å®šæ¸…ç©ºå½“å‰å­è¯é¢˜çš„èŠå¤©è®°å½•å—ï¼Ÿ')) return;
    state.messagesByTopic[activeTopic.id] = [];
    saveState();
    renderMessages();
  });

  elements.newChatBtn.addEventListener('click', () => {
    // åˆ›å»ºä¸€ä¸ªæ–°çš„ç©ºç™½è¯é¢˜
    const topicId = createId('topic');
    state.topics.push({
      id: topicId,
      name: 'æ–°è¯é¢˜',
      prompt: '',
      historyCount: 12,
      temperature: 0.7,
      activeProfileId: state.activeProfileId
    });
    state.activeTopicId = topicId;
    saveState();
    render();
  });

  elements.addTopicBtn.addEventListener('click', () => openTopicModal());
  elements.topicForm.addEventListener('submit', handleTopicSubmit);
  elements.topicCancelBtn.addEventListener('click', () => closeModal(elements.topicModal));
  elements.closeTopicBtn.addEventListener('click', () => closeModal(elements.topicModal));

  // æ¸©åº¦æ»‘å—å®æ—¶æ˜¾ç¤ºå€¼
  elements.topicTemperature.addEventListener('input', (event) => {
    elements.topicTemperatureValue.textContent = Number(event.target.value).toFixed(2);
  });

  elements.settingsBtn.addEventListener('click', () => openModal(elements.settingsModal));
  elements.closeSettingsBtn.addEventListener('click', () => closeModal(elements.settingsModal));
  elements.profileForm.addEventListener('submit', handleProfileSubmit);
  elements.profileCancelBtn.addEventListener('click', resetProfileForm);

  elements.sendKeySelect.addEventListener('change', (event) => {
    state.settings.sendKey = event.target.value;
    updateSendHint();
    saveState();
  });

  // å¯¼å‡ºæ•°æ®æŒ‰é’®
  elements.exportBtn.addEventListener('click', exportData);

  // å¯¼å…¥æ•°æ®æŒ‰é’®
  elements.importBtn.addEventListener('click', () => {
    elements.importFileInput.click();
  });

  // æ–‡ä»¶é€‰æ‹©åæ‰§è¡Œå¯¼å…¥
  elements.importFileInput.addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (file) {
      importData(file);
      // é‡ç½® input ä»¥ä¾¿å¯ä»¥é‡å¤å¯¼å…¥åŒä¸€æ–‡ä»¶
      elements.importFileInput.value = '';
    }
  });

  // ä¸€é”®é‡ç½®æŒ‰é’®
  elements.resetBtn.addEventListener('click', resetData);

  // Gist åŒæ­¥æŒ‰é’®
  elements.uploadBtn.addEventListener('click', uploadToCloud);
  elements.downloadBtn.addEventListener('click', downloadFromCloud);
  elements.saveGistBtn.addEventListener('click', saveGistConfig);

  elements.menuToggle.addEventListener('click', () => {
    elements.sidebar.classList.add('open');
    elements.sidebarOverlay.classList.add('open');
  });

  elements.sidebarClose.addEventListener('click', () => {
    elements.sidebar.classList.remove('open');
    elements.sidebarOverlay.classList.remove('open');
  });

  elements.sidebarOverlay.addEventListener('click', () => {
    elements.sidebar.classList.remove('open');
    elements.sidebarOverlay.classList.remove('open');
  });

  // å½“çª—å£å®½åº¦å˜è¶³å¤Ÿå¤§æ—¶ï¼Œè‡ªåŠ¨å…³é—­ç§»åŠ¨ç«¯ä¾§æ çŠ¶æ€
  window.addEventListener('resize', () => {
    if (window.innerWidth > 980) {
      elements.sidebar.classList.remove('open');
      elements.sidebarOverlay.classList.remove('open');
    }
  });

  window.addEventListener('click', (event) => {
    if (event.target === elements.settingsModal) {
      closeModal(elements.settingsModal);
    }
    if (event.target === elements.topicModal) {
      closeModal(elements.topicModal);
    }
  });
}

function boot() {
  ensureActiveSelections();
  render();
  initListeners();
}

// å¯¼å‡ºæ•°æ®ä¸º JSON æ–‡ä»¶
function exportData() {
  const dataStr = JSON.stringify(state, null, 2);
  const blob = new Blob([dataStr], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
  a.download = `chatbutte-backup-${timestamp}.json`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// å¯¼å…¥æ•°æ®ä» JSON æ–‡ä»¶
function importData(file) {
  const reader = new FileReader();
  reader.onload = (event) => {
    try {
      const imported = JSON.parse(event.target.result);

      // éªŒè¯å¯¼å…¥çš„æ•°æ®ç»“æ„
      if (!imported || typeof imported !== 'object') {
        alert('å¯¼å…¥å¤±è´¥ï¼šæ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®');
        return;
      }

      // åˆå¹¶å¯¼å…¥çš„æ•°æ®ï¼Œä¿ç•™é»˜è®¤ç»“æ„
      state = {
        ...structuredClone(defaultState),
        ...imported,
        settings: { ...structuredClone(defaultState.settings), ...(imported.settings || {}) },
        messagesByTopic: imported.messagesByTopic || {},
      };

      saveState();
      render();
      alert('æ•°æ®å¯¼å…¥æˆåŠŸï¼');
    } catch (error) {
      alert('å¯¼å…¥å¤±è´¥ï¼šJSON è§£æé”™è¯¯\n' + error.message);
    }
  };
  reader.readAsText(file);
}

// ä¸€é”®é‡ç½®æ‰€æœ‰æ•°æ®
function resetData() {
  if (!confirm('ç¡®å®šè¦é‡ç½®æ‰€æœ‰æ•°æ®å—ï¼Ÿ\n\næ­¤æ“ä½œå°†æ¸…ç©ºæ‰€æœ‰èŠå¤©è®°å½•ã€è¯é¢˜å’Œæ¨¡å‹é…ç½®ï¼Œæ¢å¤åˆ°åˆå§‹çŠ¶æ€ã€‚\næ­¤æ“ä½œä¸å¯æ’¤é”€ï¼')) {
    return;
  }
  if (!confirm('å†æ¬¡ç¡®è®¤ï¼šçœŸçš„è¦åˆ é™¤æ‰€æœ‰æ•°æ®å—ï¼Ÿ')) {
    return;
  }
  localStorage.removeItem(STORAGE_KEY);
  state = structuredClone(defaultState);
  render();
  alert('æ•°æ®å·²é‡ç½®ï¼Œé¡µé¢å·²æ¢å¤åˆ°åˆå§‹çŠ¶æ€ã€‚');
}

// ============ Gist åŒæ­¥ç›¸å…³å‡½æ•° ============

// ç”Ÿæˆæ•°æ®å“ˆå¸Œå€¼ï¼Œç”¨äºæ£€æµ‹æ•°æ®å˜åŒ–
function generateDataHash(data) {
  const str = JSON.stringify(data);
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // è½¬æ¢ä¸º 32 ä½æ•´æ•°
  }
  return hash.toString(36);
}

// è·å–ç”¨äºåŒæ­¥çš„æ•°æ®ï¼ˆæ’é™¤æ•æ„Ÿä¿¡æ¯ï¼‰
function getSyncData() {
  const { gistToken, lastSyncHash, lastSyncTime, ...syncData } = state;
  return syncData;
}

// æ ¼å¼åŒ–æ—¶é—´æ˜¾ç¤º
function formatTime(timestamp) {
  if (!timestamp) return 'ä»æœªåŒæ­¥';
  const date = new Date(timestamp);
  return date.toLocaleString('zh-CN');
}

// æ›´æ–°åŒæ­¥çŠ¶æ€æ˜¾ç¤º
function updateSyncStatus(message, type = 'info') {
  elements.syncStatus.textContent = message;
  elements.syncStatus.style.color = type === 'error' ? '#9f2d1f' : type === 'success' ? '#2d7a3f' : '';
}

// ä¸Šä¼ æ•°æ®åˆ° Gist
async function uploadToGist() {
  if (!state.gistToken) {
    throw new Error('è¯·å…ˆé…ç½® GitHub Gist Token');
  }

  const syncData = getSyncData();
  const content = JSON.stringify(syncData, null, 2);
  const filename = 'chatbutte-data.json';
  const description = `Chatbutte Chat Data - Synced at ${new Date().toISOString()}`;

  const headers = {
    'Authorization': `Bearer ${state.gistToken}`,
    'Content-Type': 'application/json',
    'Accept': 'application/vnd.github+json',
  };

  let url = 'https://api.github.com/gists';
  let method = 'POST';

  // å¦‚æœå·²æœ‰ gistIdï¼Œåˆ™æ›´æ–°
  if (state.gistId) {
    url = `https://api.github.com/gists/${state.gistId}`;
    method = 'PATCH';
  }

  const body = state.gistId
    ? {
        description,
        files: {
          [filename]: {
            content,
          },
        },
      }
    : {
        description,
        public: false,
        files: {
          [filename]: {
            content,
          },
        },
      };

  const response = await fetch(url, {
    method,
    headers,
    body: JSON.stringify(body),
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.message || 'ä¸Šä¼ åˆ° Gist å¤±è´¥');
  }

  const data = await response.json();

  // å¦‚æœæ˜¯æ–°åˆ›å»ºçš„ gistï¼Œä¿å­˜ gistId
  if (!state.gistId && data.id) {
    state.gistId = data.id;
    elements.gistId.value = data.id;
  }

  return data;
}

// ä» Gist ä¸‹è½½æ•°æ®
async function downloadFromGist() {
  if (!state.gistToken) {
    throw new Error('è¯·å…ˆé…ç½® GitHub Gist Token');
  }
  if (!state.gistId) {
    throw new Error('è¯·å…ˆè¿›è¡Œé¦–æ¬¡åŒæ­¥ä»¥åˆ›å»º Gist');
  }

  const headers = {
    'Authorization': `Bearer ${state.gistToken}`,
    'Accept': 'application/vnd.github+json',
  };

  const response = await fetch(`https://api.github.com/gists/${state.gistId}`, {
    method: 'GET',
    headers,
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.message || 'ä» Gist ä¸‹è½½æ•°æ®å¤±è´¥');
  }

  const data = await response.json();

  // è·å–æ–‡ä»¶å†…å®¹å’Œæ›´æ–°æ—¶é—´
  const files = data.files;
  const filename = Object.keys(files).find(f => f.endsWith('.json'));
  if (!filename || !files[filename]) {
    throw new Error('Gist ä¸­æ²¡æœ‰æ‰¾åˆ°æ•°æ®æ–‡ä»¶');
  }

  const content = files[filename].content;
  return {
    data: JSON.parse(content),
    updatedAt: data.updated_at ? new Date(data.updated_at).getTime() : Date.now(),
  };
}

// ä¸Šä¼ åˆ°äº‘ç«¯
async function uploadToCloud() {
  if (!state.gistToken) {
    updateSyncStatus('è¯·å…ˆé…ç½® Gist Token', 'error');
    return;
  }

  try {
    // å¦‚æœæ²¡æœ‰ gistIdï¼Œè¯¢é—®æ˜¯å¦åˆ›å»ºæ–°çš„
    if (!state.gistId) {
      const shouldCreate = confirm(
        'æœªæ£€æµ‹åˆ° Gist IDã€‚\n\n' +
        'ç‚¹å‡»ã€Œç¡®å®šã€åˆ›å»ºæ–°çš„ Gist å¹¶ä¸Šä¼ æ•°æ®\n' +
        'ç‚¹å‡»ã€Œå–æ¶ˆã€å–æ¶ˆä¸Šä¼ '
      );

      if (!shouldCreate) {
        updateSyncStatus('ä¸Šä¼ å·²å–æ¶ˆ', 'info');
        return;
      }
    } else {
      // æœ‰ gistIdï¼Œå…ˆæ£€æŸ¥äº‘ç«¯æ•°æ®
      try {
        const remote = await downloadFromGist();
        const remoteHash = generateDataHash(remote.data);
        const localHash = generateDataHash(getSyncData());

        // æ£€æŸ¥æ•°æ®æ˜¯å¦ä¸€è‡´
        if (localHash === remoteHash) {
          alert('âœ“ äº‘ç«¯æ•°æ®ä¸æœ¬åœ°æ•°æ®å·²ä¸€è‡´ï¼Œæ— éœ€ä¸Šä¼ ã€‚');
          updateSyncStatus('äº‘ç«¯ä¸æœ¬åœ°æ•°æ®å·²ä¸€è‡´', 'success');
          return;
        }

        // æ£€æŸ¥äº‘ç«¯æ˜¯å¦æ¯”æœ¬åœ°æ–°ï¼ˆè¢«å…¶ä»–å®¢æˆ·ç«¯ä¿®æ”¹è¿‡ï¼‰
        if (state.lastSyncHash && state.lastSyncHash !== remoteHash && localHash !== remoteHash) {
          const shouldOverwrite = confirm(
            'äº‘ç«¯æ•°æ®å·²è¢«å…¶ä»–å®¢æˆ·ç«¯ä¿®æ”¹ï¼ˆæ›´æ–°æ—¶é—´ï¼š' + formatTime(remote.updatedAt) + 'ï¼‰ã€‚\n\n' +
            'ç‚¹å‡»ã€Œç¡®å®šã€ç”¨æœ¬åœ°æ•°æ®è¦†ç›–äº‘ç«¯\n' +
            'ç‚¹å‡»ã€Œå–æ¶ˆã€å–æ¶ˆä¸Šä¼ '
          );

          if (!shouldOverwrite) {
            updateSyncStatus('ä¸Šä¼ å·²å–æ¶ˆï¼Œäº‘ç«¯æ•°æ®æœªå—å½±å“', 'info');
            return;
          }
        }
      } catch (error) {
        // æ— æ³•ä¸‹è½½äº‘ç«¯æ•°æ®ï¼ˆå¯èƒ½ Gist è¢«åˆ é™¤ï¼‰ï¼Œè¯¢é—®æ˜¯å¦åˆ›å»ºæ–°çš„
        const shouldRecreate = confirm(
          'æ— æ³•è®¿é—®äº‘ç«¯ Gistï¼ˆå¯èƒ½å·²è¢«åˆ é™¤ï¼‰ã€‚\n\n' +
          'ç‚¹å‡»ã€Œç¡®å®šã€åˆ›å»ºæ–°çš„ Gist\n' +
          'ç‚¹å‡»ã€Œå–æ¶ˆã€å–æ¶ˆä¸Šä¼ '
        );

        if (!shouldRecreate) {
          updateSyncStatus('ä¸Šä¼ å·²å–æ¶ˆ', 'info');
          return;
        }

        state.gistId = '';
        elements.gistId.value = '';
      }
    }

    // æ‰§è¡Œä¸Šä¼ 
    updateSyncStatus('æ­£åœ¨ä¸Šä¼ ...', 'info');
    const result = await uploadToGist();

    // æ›´æ–°åŒæ­¥çŠ¶æ€
    state.lastSyncTime = Date.now();
    state.lastSyncHash = generateDataHash(getSyncData());
    saveState();

    // æ›´æ–° UI
    if (!elements.gistId.value && result.id) {
      elements.gistId.value = result.id;
    }

    updateSyncStatus(`ä¸Šä¼ æˆåŠŸï¼${formatTime(state.lastSyncTime)}`, 'success');
  } catch (error) {
    updateSyncStatus(`ä¸Šä¼ å¤±è´¥ï¼š${error.message}`, 'error');
    console.error('ä¸Šä¼ å¤±è´¥:', error);
  }
}

// ä»äº‘ç«¯ä¸‹è½½
async function downloadFromCloud() {
  if (!state.gistToken) {
    updateSyncStatus('è¯·å…ˆé…ç½® Gist Token', 'error');
    return;
  }

  if (!state.gistId) {
    updateSyncStatus('è¯·å…ˆä¸Šä¼ æ•°æ®åˆ°äº‘ç«¯ä»¥åˆ›å»º Gist', 'error');
    return;
  }

  try {
    updateSyncStatus('æ­£åœ¨æ£€æŸ¥äº‘ç«¯æ•°æ®...', 'info');

    const remote = await downloadFromGist();
    const remoteData = remote.data;
    const remoteHash = generateDataHash(remoteData);
    const localHash = generateDataHash(getSyncData());

    // æ£€æŸ¥æ•°æ®æ˜¯å¦ä¸€è‡´
    if (localHash === remoteHash) {
      alert('âœ“ äº‘ç«¯æ•°æ®ä¸æœ¬åœ°æ•°æ®å·²ä¸€è‡´ï¼Œæ— éœ€ä¸‹è½½ã€‚');
      updateSyncStatus('äº‘ç«¯ä¸æœ¬åœ°æ•°æ®å·²ä¸€è‡´', 'success');
      return;
    }

    // æ•°æ®ä¸ä¸€è‡´ï¼Œè¯¢é—®æ˜¯å¦è¦†ç›–
    const shouldOverwrite = confirm(
      'âš ï¸ å³å°†ç”¨äº‘ç«¯æ•°æ®è¦†ç›–æœ¬åœ°æ‰€æœ‰æ•°æ®ã€‚\n\n' +
      'æ­¤æ“ä½œå°†æ›¿æ¢æ‰€æœ‰èŠå¤©è®°å½•ã€è¯é¢˜å’Œé…ç½®ã€‚\n' +
      'ç‚¹å‡»ã€Œç¡®å®šã€ç»§ç»­ä¸‹è½½å¹¶è¦†ç›–\n' +
      'ç‚¹å‡»ã€Œå–æ¶ˆã€ä¿ç•™æœ¬åœ°æ•°æ®'
    );

    if (!shouldOverwrite) {
      updateSyncStatus('ä¸‹è½½å·²å–æ¶ˆï¼Œæœ¬åœ°æ•°æ®æœªå—å½±å“', 'info');
      return;
    }

    updateSyncStatus('æ­£åœ¨ä¸‹è½½...', 'info');

    // ç”¨äº‘ç«¯æ•°æ®è¦†ç›–æœ¬åœ°
    const { gistToken, gistId } = state;
    state = {
      ...structuredClone(defaultState),
      ...remoteData,
      gistToken,
      gistId,
      lastSyncTime: Date.now(),
      lastSyncHash: remoteHash,
    };

    saveState();
    render();

    updateSyncStatus(`ä¸‹è½½æˆåŠŸï¼å·²ç”¨äº‘ç«¯æ•°æ®è¦†ç›–æœ¬åœ°`, 'success');
  } catch (error) {
    updateSyncStatus(`ä¸‹è½½å¤±è´¥ï¼š${error.message}`, 'error');
    console.error('ä¸‹è½½å¤±è´¥:', error);
  }
}

// ä¿å­˜ Gist é…ç½®
function saveGistConfig() {
  state.gistToken = elements.gistToken.value.trim();
  state.gistId = elements.gistId.value.trim();
  saveState();
  updateSyncStatus('é…ç½®å·²ä¿å­˜', 'success');
}

// æ¸²æŸ“ Gist é…ç½®
function renderGistConfig() {
  elements.gistToken.value = state.gistToken || '';
  elements.gistId.value = state.gistId || '';

  if (state.lastSyncTime) {
    updateSyncStatus(`ä¸Šæ¬¡æ“ä½œï¼š${formatTime(state.lastSyncTime)}`);
  } else {
    updateSyncStatus('æ‰‹åŠ¨æ§åˆ¶æ•°æ®åŒæ­¥ï¼Œå¯é€‰æ‹©ä¸Šä¼ æˆ–ä¸‹è½½');
  }
}

boot();
